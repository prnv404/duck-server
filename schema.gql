# ------------------------------------------------------
# THIS FILE WAS AUTOMATICALLY GENERATED (DO NOT MODIFY)
# ------------------------------------------------------

type AnswerOption {
  createdAt: DateTime!
  id: ID!
  isCorrect: Boolean!
  optionOrder: Int
  optionText: String!
  question: QuestionModel
  questionId: ID!
}

type AuthResponse {
  accessToken: String!
  refreshToken: String!
  user: User!
}

type Badge {
  badgeType: String
  createdAt: DateTime!
  description: String
  iconUrl: String
  id: ID!
  name: String!
  unlockCriteria: JSON!
  xpReward: Int!
}

input CreateSessionInput {
  subjectIds: [ID!]
  topicId: ID
  totalQuestions: Int
  type: String!
  userId: ID!
}

input CreateUserInput {
  fullName: String
  otp: String!
  phone: String!
  targetExam: String
  username: String!
}

"""
A date-time string at UTC, such as 2019-12-03T09:54:33Z, compliant with the date-time format.
"""
scalar DateTime

"""
The `JSON` scalar type represents JSON values as specified by [ECMA-404](http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf).
"""
scalar JSON @specifiedBy(url: "http://www.ecma-international.org/publications/files/ECMA-ST/ECMA-404.pdf")

type LeaderboardEntry {
  createdAt: DateTime!
  id: ID!
  periodEnd: DateTime
  periodStart: DateTime!
  periodType: PeriodType!
  quizzesCompleted: Int!
  rank: Int
  updatedAt: DateTime!
  userId: ID!
  xpEarned: Int!
}

type Mutation {
  completeSession(sessionId: String!): PracticeSession!
  createPracticeSession(input: CreateSessionInput!): PracticeSessionWithQuestions!

  """Register a new user account"""
  createUser(input: CreateUserInput!): User!

  """Delete the user's account"""
  deleteUser(
    """The ID of the user to delete"""
    id: ID!
  ): User!
  logout: Boolean!
  refreshTokens: RefreshTokenResponse!
  requestOtp(input: RequestOtpInput!): Boolean!
  submitAnswer(input: SubmitAnswerInput!): SessionAnswerModel!

  """Update an existing user profile"""
  updateUser(input: UpdateUserInput!): User!
  verifyOtp(input: VerifyOtpInput!): AuthResponse!
}

type NotificationQueue {
  body: String!
  createdAt: DateTime!
  id: ID!
  notificationType: String
  scheduledAt: DateTime!
  sentAt: DateTime
  status: NotificationStatus!
  title: String!
  user: User!
  userId: ID!
}

"""Notification queue status"""
enum NotificationStatus {
  FAILED
  PENDING
  SENT
}

"""Leaderboard period types"""
enum PeriodType {
  ALL_TIME
  MONTHLY
  WEEKLY
}

type PracticeSession {
  accuracy: String!
  balanceStrategy: String!
  completedAt: DateTime
  correctAnswers: Int!
  createdAt: DateTime!
  id: ID!
  questionsAttempted: Int!
  sessionAnswers: [SessionAnswerModel!]!
  sessionType: String!
  startedAt: DateTime!
  status: SessionStatus!
  subjectDistribution: JSON!
  timeSpentSeconds: Int
  topic: TopicModel
  topicDistribution: JSON!
  topicId: ID
  totalQuestions: Int!
  user: User!
  userId: ID!
  wrongAnswers: Int!
  xpEarned: Int!
}

type PracticeSessionWithQuestions {
  accuracy: String!
  balanceStrategy: String!
  completedAt: DateTime
  correctAnswers: Int!
  createdAt: DateTime!
  id: ID!
  questions: [QuestionModel!]!
  questionsAttempted: Int!
  sessionAnswers: [SessionAnswerModel!]!
  sessionType: String!
  startedAt: DateTime!
  status: SessionStatus!
  subjectDistribution: JSON!
  timeSpentSeconds: Int
  topic: TopicModel
  topicDistribution: JSON!
  topicId: ID
  totalQuestions: Int!
  user: User!
  userId: ID!
  wrongAnswers: Int!
  xpEarned: Int!
}

type Query {
  getPracticeSession(sessionId: String!): PracticeSession!

  """Get a user by ID"""
  getUser(
    """The string ID of the user"""
    id: ID!
  ): User!

  """Get a list of all users"""
  getUsers(limit: Int! = 10, offset: Int! = 0): [User!]!

  """Get the profile of the authenticated user"""
  me: User!
  subjectById(id: String!): SubjectModel!
  subjects: [SubjectModel!]!
  topicById(id: String!): TopicModel!
  topicsBySubjectId(subjectId: String!): [TopicModel!]!
}

type QuestionModel {
  answerOptions: [AnswerOption!]!
  createdAt: DateTime!
  difficulty: Int!
  explanation: String
  id: ID!
  isActive: Boolean!
  points: Int!
  questionText: String!
  timesAttempted: Int!
  timesCorrect: Int!
  topic: TopicModel
  topicId: ID
}

type RefreshTokenResponse {
  accessToken: String!
  refreshToken: String!
}

input RequestOtpInput {
  phone: String!
}

type SessionAnswerModel {
  answeredAt: DateTime!
  id: ID!
  isCorrect: Boolean!
  question: QuestionModel!
  questionId: ID!
  selectedOption: AnswerOption
  selectedOptionId: ID
  session: PracticeSession!
  sessionId: ID!
  timeSpentSeconds: Int
}

"""Quiz session status"""
enum SessionStatus {
  ABANDONED
  COMPLETED
  DRAFT
  IN_PROGRESS
  PAUSED
}

type StreakCalendar {
  activityDate: DateTime!
  createdAt: DateTime!
  id: ID!
  questionsAnswered: Int!
  quizzesCompleted: Int!
  userId: ID!
  xpEarned: Int!
}

type SubjectModel {
  colorCode: String
  createdAt: DateTime!
  displayOrder: Int
  iconUrl: String
  id: ID!
  isActiveInRandom: Boolean
  name: String!
  topics: [TopicModel!]
  weightage: Int
}

input SubmitAnswerInput {
  questionId: ID!
  selectedOptionId: String
  sessionId: ID!
  timeSpentSeconds: Int!
}

type TopicModel {
  createdAt: DateTime!
  description: String
  displayOrder: Int
  id: ID!
  isActiveInRandom: Boolean
  name: String!
  subject: SubjectModel!
  subjectId: ID!
  weightage: Int
}

input UpdateUserInput {
  avatarUrl: String
  fcmToken: String
  fullName: String
  id: String!
  notificationEnabled: Boolean
  targetExam: String
  username: String
}

type User {
  avatarUrl: String
  createdAt: DateTime!
  fcmToken: String
  fullName: String
  id: ID!
  lastActiveAt: DateTime
  leaderboardEntries: [LeaderboardEntry!]!
  notificationEnabled: Boolean!
  notificationQueue: [NotificationQueue!]!
  otp: String
  phone: String!
  quizSessions: [PracticeSession!]!
  refreshToken: String
  streakCalendar: [StreakCalendar!]!
  targetExam: String
  userBadges: [UserBadge!]!
  userQuestionHistory: [UserQuestionHistory!]!
  userQuizPreferences: UserPracticePreferenceModel!
  userStats: UserStats!
  userTopicProgress: [UserTopicProgress!]!
  username: String!
}

type UserBadge {
  badge: Badge!
  badgeId: ID!
  createdAt: DateTime!
  id: ID!
  progressPercentage: Float!
  unlockedAt: DateTime
  userId: ID!
}

type UserPracticePreferenceModel {
  allowQuestionRepetition: Boolean!
  avoidRecentQuestionsDays: Int!
  createdAt: DateTime!
  defaultBalanceStrategy: String!
  defaultQuestionsPerSession: Int!
  defaultTimeLimitSeconds: Int
  difficultyAdaptationEnabled: Boolean!
  excludedSubjectIds: [ID!]!
  id: ID!
  minQuestionsForWeakDetection: Int!
  preferredDifficulty: Int
  preferredSubjectIds: [ID!]!
  updatedAt: DateTime!
  user: User!
  userId: ID!
  weakAreaThreshold: Float!
}

type UserQuestionHistory {
  id: ID!
  lastSeenAt: DateTime!
  question: QuestionModel!
  questionId: ID!
  timesCorrect: Int!
  timesSeen: Int!
  user: User!
  userId: ID!
}

type UserStats {
  createdAt: DateTime!
  currentStreak: Int!
  energy: Int!
  id: ID!
  lastActivityDate: DateTime
  level: Int!
  longestStreak: Int!
  overallAccuracy: String!
  totalCorrectAnswers: Int!
  totalPracticeTimeMinutes: Int!
  totalQuestionsAttempted: Int!
  totalQuizzesCompleted: Int!
  totalXp: Int!
  updatedAt: DateTime!
  userId: ID!
  xpToNextLevel: Int!
}

type UserTopicProgress {
  accuracy: Float!
  correctAnswers: Int!
  createdAt: DateTime!
  id: ID!
  lastPracticedAt: DateTime
  questionsAttempted: Int!
  topic: TopicModel!
  topicId: ID!
  updatedAt: DateTime!
  user: User!
  userId: ID!
}

input VerifyOtpInput {
  otp: String!
  phone: String!
}